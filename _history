{"entries":[{"timestamp":1772006379624,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":135,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":33,"diffs":[[1,"\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":108,"length1":149,"diffs":[[1,"        \"microphone\": \"*\"\n"]]},{"start1":198,"length1":41,"diffs":[[1,"        \"README.md\"\n"]]},{"start1":225,"length1":35,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"custom.ts","value":"//% color=\"#00C04A\" weight=100 icon=\"\\uf1b9\" block=\"æ™ºèƒ½IICå®æˆ˜å·¡çº¿\"\nnamespace AnalogLineFollow {\n    // PID ä¸åŸºç¡€å‚æ•°\n    let _kp = 0;\n    let _ki = 0;\n    let _kd = 0;\n    let _prevError = 0;\n    let _integral = 0;\n    let _baseSpeed = 60;\n    let _brake = 1;\n    let _internalThreshold = 150;\n\n    // çŠ¶æ€è®°å¿†\n    let _lastLeftSpeed = 0;\n    let _lastRightSpeed = 0;\n    let _isWhiteLine = false;\n\n    // ğŸš€ åº•ç›˜ç¡¬ä»¶æ ¡å‡†ç³»æ•°ï¼ˆé»˜è®¤1.0ï¼Œå³100%åŠ¨åŠ›ï¼‰\n    let _leftMotorScale = 1.0;\n    let _rightMotorScale = 1.0;\n\n    export enum TurnDir {\n        //% block=\"å·¦\"\n        Left,\n        //% block=\"å³\"\n        Right\n    }\n\n    export enum LineType {\n        //% block=\"é»‘çº¿(ç™½åº•)\"\n        Black,\n        //% block=\"ç™½çº¿(é»‘åº•)\"\n        White\n    }\n\n    export enum IntersectType {\n        //% block=\"å·¦è·¯å£\"\n        Left,\n        //% block=\"å³è·¯å£\"\n        Right,\n        //% block=\"åå­—/åœæ­¢çº¿\"\n        Cross,\n        //% block=\"ä»»æ„è·¯å£\"\n        Any\n    }\n\n    export enum IntersectAction {\n        //% block=\"å¹³æ»‘åœè½¦\"\n        Stop,\n        //% block=\"å†²è¿‡è·¯å£(ç›²å¼€)\"\n        CrossOver\n    }\n\n    // ==========================================\n    // ğŸš€ æ ¸å¿ƒåº•å±‚ï¼šæ‰€æœ‰é€Ÿåº¦æŒ‡ä»¤å¿…é¡»ç»è¿‡æ­¤æ‹¦æˆªå™¨ï¼\n    // ==========================================\n    function _setMotorSpeed(left: number, right: number): void {\n        let finalL = left * _leftMotorScale;\n        let finalR = right * _rightMotorScale;\n\n        // é™åˆ¶è¾“å‡ºåœ¨ -100 åˆ° 100 ä¹‹é—´ï¼Œé˜²æ­¢æ•°å€¼çˆ†ç‚¸\n        finalL = Math.max(-100, Math.min(100, finalL));\n        finalR = Math.max(-100, Math.min(100, finalR));\n\n        neZha.setMotorSpeed(neZha.MotorList.M1, Math.round(finalL));\n        neZha.setMotorSpeed(neZha.MotorList.M2, Math.round(finalR));\n    }\n\n    //% block=\"åˆå§‹åŒ– IICå·¡çº¿ Kp $p Ki $i Kd $d åŸºç¡€é€Ÿåº¦ $baseSpeed åˆ¹è½¦ $brake èµ›é“ $line\"\n    //% p.defl=0.07 i.defl=0 d.defl=0.09 baseSpeed.defl=60 brake.defl=1\n    //% weight=100\n    export function setPID(p: number, i: number, d: number, baseSpeed: number, brake: number, line: LineType): void {\n        _kp = p;\n        _ki = i;\n        _kd = d;\n        _baseSpeed = baseSpeed;\n        _brake = brake;\n        _isWhiteLine = (line === LineType.White);\n        _integral = 0;\n        _prevError = 0;\n    }\n\n    // ğŸš€ å®æˆ˜ç§¯æœ¨ 3ï¼šåº•ç›˜ç¡¬ä»¶æ ¡å‡† (å®Œç¾ä¿®å¤è¾“å…¥æ¡†Bug)\n    //% block=\"æ ¡å‡†åº•ç›˜ï¼šå·¦è½®åŠ¨åŠ› $left | å³è½®åŠ¨åŠ› $right\"\n    //% left.defl=100 left.min=50 left.max=100\n    //% right.defl=100 right.min=50 right.max=100\n    //% weight=95\n    export function calibrateMotor(left: number, right: number): void {\n        _leftMotorScale = left / 100.0;\n        _rightMotorScale = right / 100.0;\n    }\n\n    //% block=\"å¹³æ»‘èµ·æ­¥/å˜é€Ÿ ç›®æ ‡é€Ÿåº¦ $targetSpeed æ­¥è¿›å»¶è¿Ÿ(ms) $delayMs\"\n    //% targetSpeed.defl=60 delayMs.defl=20\n    //% weight=90\n    export function smoothStart(targetSpeed: number, delayMs: number): void {\n        let currentS = Math.round((_lastLeftSpeed + _lastRightSpeed) / 2);\n        let step = (targetSpeed >= currentS) ? 5 : -5;\n\n        for (let s = currentS; (step > 0 ? s <= targetSpeed : s >= targetSpeed); s += step) {\n            _setMotorSpeed(s, s);\n            _lastLeftSpeed = s;\n            _lastRightSpeed = s;\n            basic.pause(delayMs);\n        }\n        _setMotorSpeed(targetSpeed, targetSpeed);\n        _lastLeftSpeed = targetSpeed;\n        _lastRightSpeed = targetSpeed;\n    }\n\n    //% block=\"å¹³æ»‘åˆ¹è½¦ æ­¥è¿›å»¶è¿Ÿ(ms) $delayMs\"\n    //% delayMs.defl=20\n    //% weight=80\n    export function smoothBrake(delayMs: number): void {\n        let steps = 10;\n        let leftStep = _lastLeftSpeed / steps;\n        let rightStep = _lastRightSpeed / steps;\n\n        for (let i = 0; i < steps; i++) {\n            _lastLeftSpeed -= leftStep;\n            _lastRightSpeed -= rightStep;\n            _setMotorSpeed(_lastLeftSpeed, _lastRightSpeed);\n            basic.pause(delayMs);\n        }\n        _setMotorSpeed(0, 0);\n        _lastLeftSpeed = 0;\n        _lastRightSpeed = 0;\n    }\n\n    // ğŸš€ å®æˆ˜ç§¯æœ¨ 2ï¼šæ™ºèƒ½åŸåœ°æ­»è½¬ç›´åˆ°çº¿ä¸Š\n    //% block=\"åŸåœ°æ­»è½¬å‘ $dir ç›´åˆ°æ­£å¯¹çº¿ä¸Š | é€Ÿåº¦ $speed\"\n    //% speed.defl=40\n    //% weight=75\n    export function turnUntilLine(dir: TurnDir, speed: number): void {\n        let leftS = dir === TurnDir.Left ? -speed : speed;\n        let rightS = dir === TurnDir.Left ? speed : -speed;\n\n        _setMotorSpeed(leftS, rightS);\n        basic.pause(200); // å…ˆç›²è½¬0.2ç§’ï¼Œå¼ºè¡Œè„±ç¦»å½“å‰å‹ç€çš„é»‘çº¿\n\n        while (true) {\n            // è°ƒç”¨ V8 å¼•æ“çš„é«˜ç²¾åº¦åç§»é‡ï¼Œåªè¦åå·®åœ¨ -400 åˆ° 400 ä¹‹é—´ï¼Œè¯´æ˜è½¦å¤´å·²ç»å®Œç¾æ­£å¯¹é»‘çº¿ï¼\n            let offset = PlanetX_Basic.TrackBit_get_offset();\n            if (Math.abs(offset) < 400) {\n                break;\n            }\n            basic.pause(5);\n        }\n        _setMotorSpeed(0, 0); // ç¬é—´æ­»åˆ¹\n        _lastLeftSpeed = 0;\n        _lastRightSpeed = 0;\n        basic.pause(50);\n    }\n\n    // ğŸš€ å®æˆ˜ç§¯æœ¨ 1ï¼šä¸‡èƒ½è·¯å£è®¡æ•°å™¨ (åˆ é™¤äº†å¤šä½™çš„å•è·¯å£ç§¯æœ¨ï¼Œè¿™ä¸ªå…¨åŒ…äº†ï¼)\n    //% block=\"PIDå·¡çº¿ ç»è¿‡ $count ä¸ª $intersectType å $action | å†²è¿‡é€Ÿåº¦ $crossSpeed æŒç»­(ms) $crossTime\"\n    //% count.defl=1 crossSpeed.defl=40 crossTime.defl=300\n    //% weight=73\n    export function pidCrossMultiple(count: number, intersectType: IntersectType, action: IntersectAction, crossSpeed: number, crossTime: number): void {\n        let metCount = 0; // è®°å½•é‡åˆ°äº†å‡ ä¸ªè·¯å£\n\n        while (metCount < count) {\n            PlanetX_Basic.Trackbit_get_state_value();\n            let l2 = PlanetX_Basic.TrackbitgetGray(PlanetX_Basic.TrackbitChannel.One);\n            let r2 = PlanetX_Basic.TrackbitgetGray(PlanetX_Basic.TrackbitChannel.Four);\n\n            let l2_on = _isWhiteLine ? (l2 > _internalThreshold) : (l2 < _internalThreshold);\n            let r2_on = _isWhiteLine ? (r2 > _internalThreshold) : (r2 < _internalThreshold);\n\n            let isMet = false;\n            if (intersectType === IntersectType.Left) isMet = l2_on;\n            else if (intersectType === IntersectType.Right) isMet = r2_on;\n            else if (intersectType === IntersectType.Cross) isMet = (l2_on && r2_on);\n            else if (intersectType === IntersectType.Any) isMet = (l2_on || r2_on);\n\n            if (isMet) {\n                metCount++; // å‘ç°ç›®æ ‡è·¯å£ï¼Œè®¡æ•°+1\n\n                if (metCount >= count) {\n                    // å¦‚æœæ•°é‡è¾¾æ ‡ï¼Œæ‰§è¡Œæœ€ç»ˆåŠ¨ä½œ\n                    if (action === IntersectAction.Stop) {\n                        smoothBrake(10);\n                    } else if (action === IntersectAction.CrossOver) {\n                        _setMotorSpeed(crossSpeed, crossSpeed);\n                        basic.pause(crossTime);\n                        _lastLeftSpeed = crossSpeed;\n                        _lastRightSpeed = crossSpeed;\n                    }\n                    break; // å½»åº•ç»“æŸè¿™ä¸ªæ–¹å—\n                } else {\n                    // å¦‚æœæ•°é‡è¿˜æ²¡è¾¾æ ‡ (é‡åˆ°äº†è·¯å£ä½†è¿˜éœ€è¦ç»§ç»­èµ°)\n                    // ğŸš€ æ ¸å¿ƒé˜²æŠ–æœºåˆ¶ï¼šç«‹åˆ»é—­çœ¼å†²åˆº 300 æ¯«ç§’è·¨è¿‡è¿™æ ¹é»‘çº¿ï¼Œé˜²æ­¢ 5 æ¯«ç§’åæŠŠåŒä¸€æ ¹çº¿å½“æˆä¸‹ä¸€ä¸ªè·¯å£ï¼\n                    let passSpeed = Math.max(35, _baseSpeed);\n                    _setMotorSpeed(passSpeed, passSpeed);\n                    basic.pause(300); // å†·å´æ—¶é—´ (è·¨è¶Šè·¯å£)\n                }\n            } else {\n                pidRun(); // æ²¡é‡åˆ°è·¯å£å°±æ­£å¸¸å·¡çº¿\n                basic.pause(5);\n            }\n        }\n    }\n\n    //% block=\"è‡ªåŠ¨å¯¹é½åœæ­¢çº¿(åå­—/Tå‹) | è°ƒæ•´é€Ÿåº¦ $speed\"\n    //% speed.defl=30\n    //% weight=71\n    export function alignToLine(speed: number): void {\n        let alignedCount = 0;\n        let timeout = input.runningTime() + 3000;\n\n        while (alignedCount < 3 && input.runningTime() < timeout) {\n            PlanetX_Basic.Trackbit_get_state_value();\n            let l2 = PlanetX_Basic.TrackbitgetGray(PlanetX_Basic.TrackbitChannel.One);\n            let r2 = PlanetX_Basic.TrackbitgetGray(PlanetX_Basic.TrackbitChannel.Four);\n\n            let l2_on = _isWhiteLine ? (l2 > _internalThreshold) : (l2 < _internalThreshold);\n            let r2_on = _isWhiteLine ? (r2 > _internalThreshold) : (r2 < _internalThreshold);\n\n            let leftSpeed = 0;\n            let rightSpeed = 0;\n\n            if (!l2_on) leftSpeed = speed;\n            if (!r2_on) rightSpeed = speed;\n\n            if (l2_on && r2_on) {\n                alignedCount++;\n                leftSpeed = 0;\n                rightSpeed = 0;\n            } else {\n                alignedCount = 0;\n            }\n\n            _setMotorSpeed(leftSpeed, rightSpeed);\n            basic.pause(15);\n        }\n\n        _setMotorSpeed(0, 0);\n        _lastLeftSpeed = 0;\n        _lastRightSpeed = 0;\n        basic.pause(100);\n    }\n\n    //% block=\"æ‰§è¡Œä¸€æ¬¡PIDç°åº¦å·¡çº¿\"\n    //% weight=70\n    export function pidRun(): void {\n        let error = PlanetX_Basic.TrackBit_get_offset();\n\n        if (_isWhiteLine) {\n            error = -error;\n        }\n\n        _integral += error;\n        let derivative = error - _prevError;\n\n        let adjustment = (_kp * error) + (_ki * _integral) + (_kd * derivative);\n\n        _prevError = error;\n\n        let curveSharpness = Math.abs(error) / 100;\n        let dynamicBaseSpeed = _baseSpeed - (curveSharpness * _brake);\n        dynamicBaseSpeed = Math.max(15, dynamicBaseSpeed);\n\n        let leftSpeed = dynamicBaseSpeed + adjustment;\n        let rightSpeed = dynamicBaseSpeed - adjustment;\n\n        // è¿™é‡Œåªé™åˆ¶é€»è¾‘è®¡ç®—çš„é€Ÿåº¦\n        leftSpeed = Math.max(-100, Math.min(100, leftSpeed));\n        rightSpeed = Math.max(-100, Math.min(100, rightSpeed));\n\n        _lastLeftSpeed = leftSpeed;\n        _lastRightSpeed = rightSpeed;\n\n        // å®é™…è¾“å‡ºä¾ç„¶ä¼šè¢«åº•å±‚çš„æ ¡å‡†æ‹¦æˆªå™¨å¤„ç†\n        _setMotorSpeed(leftSpeed, rightSpeed);\n    }\n    // ğŸš€ å®æˆ˜ç§¯æœ¨ 4ï¼šç²¾å‡†æ ¡å‡†å‰è¿› (å¸¦è‡ªåŠ¨åˆ¹è½¦)\n    //% block=\"ä»¥ $speed é€Ÿåº¦å‰è¿› æŒç»­(ms) $timeMs\"\n    //% speed.min=10 speed.max=100 speed.defl=50\n    //% timeMs.defl=1000\n    //% weight=94\n    export function forwardCalibrated(speed: number, timeMs: number): void {\n        let safeSpeed = Math.abs(speed); // é˜²å‘†ï¼šé˜²æ­¢è¯¯å¡«è´Ÿæ•°\n\n        // ç›´æ¥è°ƒç”¨åº•å±‚æ‹¦æˆªå™¨ï¼Œå®ƒä¼šè‡ªåŠ¨å¸®ä½ ä¹˜ä¸Šåº•ç›˜æ ¡å‡†æ¯”ä¾‹ï¼\n        _setMotorSpeed(safeSpeed, safeSpeed);\n\n        // åŒæ­¥çŠ¶æ€è®°å¿†ï¼Œæ–¹ä¾¿åç»­å¦‚æœæ¥å¹³æ»‘åˆ¹è½¦èƒ½è¯»å–åˆ°æ­£ç¡®é€Ÿåº¦\n        _lastLeftSpeed = safeSpeed;\n        _lastRightSpeed = safeSpeed;\n\n        basic.pause(timeMs); // æŒç»­è¿è¡Œè®¾å®šçš„æ—¶é—´\n\n        // è·‘å®Œç¬é—´åˆ¹è½¦ï¼Œå¹¶æ¸…é›¶é€Ÿåº¦è®°å¿†\n        _setMotorSpeed(0, 0);\n        _lastLeftSpeed = 0;\n        _lastRightSpeed = 0;\n    }\n\n    // ğŸš€ å®æˆ˜ç§¯æœ¨ 5ï¼šç²¾å‡†æ ¡å‡†åé€€ (å¸¦è‡ªåŠ¨åˆ¹è½¦)\n    //% block=\"ä»¥ $speed é€Ÿåº¦åé€€ æŒç»­(ms) $timeMs\"\n    //% speed.min=10 speed.max=100 speed.defl=50\n    //% timeMs.defl=1000\n    //% weight=93\n    export function backwardCalibrated(speed: number, timeMs: number): void {\n        let safeSpeed = Math.abs(speed);\n\n        // åé€€å°±æ˜¯åŠ ä¸Šè´Ÿå·ï¼Œåº•å±‚ä¾ç„¶ä¼šå®Œç¾æŒ‰æ¯”ä¾‹åˆ†é…è´Ÿç”µå‹ï¼\n        _setMotorSpeed(-safeSpeed, -safeSpeed);\n        _lastLeftSpeed = -safeSpeed;\n        _lastRightSpeed = -safeSpeed;\n\n        basic.pause(timeMs);\n\n        _setMotorSpeed(0, 0);\n        _lastLeftSpeed = 0;\n        _lastRightSpeed = 0;\n    }\n\n}"}]},{"timestamp":1772006775817,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":133,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"device_forever\" x=\"20\" y=\"20\"></block></xml>"]]}]}]},{"timestamp":1772007470722,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1,"diffs":[[1,"basic.forever(function () {\n\t\n})\n"]]}]}]},{"timestamp":1772007487221,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":84,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"device_forever\" x=\"0\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":369,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// åœ¨æ­¤å¤„æµ‹è¯•ï¼›å½“æ­¤è½¯ä»¶åŒ…ä½œä¸ºæ’ä»¶ä½¿ç”¨æ—¶ï¼Œå°†ä¸ä¼šç¼–è¯‘æ­¤è½¯ä»¶åŒ…ã€‚\n"}]}],"snapshots":[{"timestamp":1772006379623,"editorVersion":"8.0.18","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"cs\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1772007601174}